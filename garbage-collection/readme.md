# Golang 内存垃圾回收
Golang的垃圾回收（GC）算法使用的是
- 无无分代（对象没有代际之分）：
  Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。

- 不整理（回收过程中不对对象进行移动与整理）：
  Go 运行时的分配算法基于tcmalloc（Thread-Caching Malloc），基本上没有碎片问题。

- 并发（与用户代码并发执行）的：
  Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。

- 三色标记清扫算法
## 三色标记法原理
三色标记法将对象分为三类，并用不同的颜色相称：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。

- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。

- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

标记过程如下：

（1）起初所有的对象都是白色的；

（2）从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；

（3）从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；

（4）重复步骤（3），直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象；

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

- 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
- 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
- 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

## STW
Stop The World

垃圾回收的原则是不应出现对象的丢失，也不应错误的回收还不需要回收的对象。
- 插入屏障
- 删除屏障
- 混合屏障

## 什么时候进行清理？

主动触发（runtime.GC()） 被动触发 （GC百分比、定时）


## References
-[liangyaopei](https://liangyaopei.github.io/2021/01/02/golang-gc-intro/)
